using Microsoft.AspNetCore.Mvc;
// using Microsoft.EntityFrameworkCore; // Remove EF Core
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
// using AnastasiiaPortfolio.Data; // Remove EF Core Data
using AnastasiiaPortfolio.Models;
using System.Security.Claims;
using MongoDB.Driver; // Add MongoDB
using MongoDB.Bson; // Add Bson
using System.Linq.Expressions; // For filters

namespace AnastasiiaPortfolio.Controllers
{
    [Authorize]
    public class ReviewsController : Controller
    {
        // Replace DbContext with IMongoDatabase
        private readonly IMongoCollection<Review> _reviewsCollection;
        private readonly IMongoCollection<Project> _projectsCollection;
        private readonly IMongoCollection<ReviewVote> _reviewVotesCollection;
        private readonly IMongoCollection<ApplicationUser> _usersCollection; // Needed for Admin view user list
        private readonly UserManager<ApplicationUser> _userManager;

        public ReviewsController(IMongoDatabase database, UserManager<ApplicationUser> userManager)
        {
            _userManager = userManager ?? throw new ArgumentNullException(nameof(userManager));
            _reviewsCollection = database.GetCollection<Review>("Reviews");
            _projectsCollection = database.GetCollection<Project>("Projects");
            _reviewVotesCollection = database.GetCollection<ReviewVote>("ReviewVotes");
            _usersCollection = database.GetCollection<ApplicationUser>("Users"); // Identity stores users in "Users" collection by default
        }

        // GET: Reviews/Admin
        [Authorize(Roles = "Admin")]
        public async Task<IActionResult> Admin(Guid? userId = null, bool showHidden = false)
        {
            var filterBuilder = Builders<Review>.Filter;
            var filter = filterBuilder.Empty; // Start with an empty filter

            if (userId != null)
            {
                filter &= filterBuilder.Eq(r => r.UserId, userId.Value);
            }

            if (!showHidden)
            {
                filter &= filterBuilder.Eq(r => r.IsHidden, false);
            }

            var reviews = await _reviewsCollection.Find(filter)
                                        .Sort(Builders<Review>.Sort.Descending(r => r.CreatedAt))
                                        .ToListAsync();

            // --- Fetch related data --- 
            // Get distinct UserIds and ProjectIds from the fetched reviews
            var userIdsInReviews = reviews.Select(r => r.UserId).Where(id => id.HasValue).Distinct().ToList();
            var projectIdsInReviews = reviews.Select(r => r.ProjectId).Where(id => id.HasValue).Distinct().ToList();

            // Fetch corresponding Users and Projects
            var usersTask = _usersCollection.Find(u => userIdsInReviews.Contains(u.Id)).ToListAsync();
            var projectsTask = _projectsCollection.Find(p => projectIdsInReviews.Contains(p.Id)).ToListAsync();
            
            await Task.WhenAll(usersTask, projectsTask);

            // Create dictionaries for easy lookup in the view
            ViewBag.UsersLookup = usersTask.Result.ToDictionary(u => u.Id, u => u.UserName ?? u.Email); // Use UserName or Email
            ViewBag.ProjectsLookup = projectsTask.Result.ToDictionary(p => p.Id, p => p.Title);
            // --- End Fetch related data --- 

            // Get all users for the filter dropdown
            var allUsers = await _usersCollection.Find(_ => true).ToListAsync(); 

            ViewBag.Users = allUsers; // For dropdown
            ViewBag.SelectedUserId = userId;
            ViewBag.ShowHidden = showHidden;

            return View(reviews); // Pass the list of Review models
        }

        // GET: Reviews/Create
        [Authorize]
        public async Task<IActionResult> Create(Guid projectId) // Change projectId to Guid
        {
            // Verify Project exists
            var projectExists = await _projectsCollection.CountDocumentsAsync(p => p.Id == projectId) > 0;
            if (!projectExists)
            {
                return NotFound();
            }

            var user = await _userManager.GetUserAsync(User);
            if (user == null) return Challenge();

            var model = new Review
            {
                ProjectId = projectId,
                UserId = user.Id, // Assign Guid ID
                Name = user.UserName ?? "Anonymous", // Use UserName from ApplicationUser
                Comment = string.Empty,
                // Id will be generated by MongoDB or constructor
            };

            return View(model);
        }

        // POST: Reviews/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        [Authorize]
        public async Task<IActionResult> Create([Bind("ProjectId,Rating,Comment,Name,Title,Pros,Cons")] Review review) // Bind relevant fields
        {
            // Re-enable validation check
            if (ModelState.IsValid)
            {
                var user = await _userManager.GetUserAsync(User);
                if (user == null) return Challenge();

                // Verify Project exists
                var projectExists = await _projectsCollection.CountDocumentsAsync(p => p.Id == review.ProjectId.GetValueOrDefault()) > 0;
                if (!projectExists)
                {
                    // Add model error or return NotFound
                    ModelState.AddModelError("ProjectId", "Invalid Project ID");
                    return View(review); // Return view with error
                }

                review.UserId = user.Id;
                review.CreatedAt = DateTime.UtcNow;
                review.Id = Guid.NewGuid(); // Ensure Id is generated

                await _reviewsCollection.InsertOneAsync(review);
                return RedirectToAction("Details", "Projects", new { id = review.ProjectId });
            }
            // Return view with model to display validation errors
            return View(review);
        }

        // GET: Reviews/Edit (Assuming an Edit view exists)
        [Authorize]
        public async Task<IActionResult> Edit(Guid id) // Change id to Guid
        {
            var review = await _reviewsCollection.Find(r => r.Id == id).FirstOrDefaultAsync();
            if (review == null)
            {
                return NotFound();
            }

            var user = await _userManager.GetUserAsync(User);
            if (user == null || review.UserId != user.Id)
            {
                 // Optional: Allow Admins to edit any review
                 if (!User.IsInRole("Admin"))
                 {
                    return Forbid();
                 }
            }

            return View(review); // Assuming an Edit.cshtml view exists for Reviews
        }

        // POST: Reviews/Edit/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        [Authorize]
        public async Task<IActionResult> Edit(Guid id, [Bind("Id,ProjectId,Rating,Comment,Name,Title,Pros,Cons,IsHidden,IsVerified,IsFeatured")] Review review) // Change id to Guid, bind fields
        {
            // Check bound ID matches route ID
            if (id != review.Id)
            {
                return NotFound();
            }

            // Re-enable validation check
            if (ModelState.IsValid)
            {
                var user = await _userManager.GetUserAsync(User);
                if (user == null) return Challenge();

                var existingReviewFilter = Builders<Review>.Filter.Eq(r => r.Id, id);
                var existingReview = await _reviewsCollection.Find(existingReviewFilter).FirstOrDefaultAsync();

                if (existingReview == null)
                {
                    return NotFound();
                }

                // Check ownership or admin role
                bool isAdmin = User.IsInRole("Admin");
                if (existingReview.UserId != user.Id && !isAdmin)
                {
                    return Forbid();
                }

                 // Prepare update definition
                var updateBuilder = Builders<Review>.Update;
                var updates = new List<UpdateDefinition<Review>>();

                // Preserve immutable fields like ProjectId, UserId, CreatedAt
                // Update editable fields from the bound model
                updates.Add(updateBuilder.Set(r => r.Rating, review.Rating));
                updates.Add(updateBuilder.Set(r => r.Comment, review.Comment));
                updates.Add(updateBuilder.Set(r => r.Name, review.Name));
                updates.Add(updateBuilder.Set(r => r.Title, review.Title));
                updates.Add(updateBuilder.Set(r => r.Pros, review.Pros));
                updates.Add(updateBuilder.Set(r => r.Cons, review.Cons));
                updates.Add(updateBuilder.Set(r => r.UpdatedAt, DateTime.UtcNow));

                // Only Admins can change these fields
                if (isAdmin)
                {
                    updates.Add(updateBuilder.Set(r => r.IsHidden, review.IsHidden));
                    updates.Add(updateBuilder.Set(r => r.IsVerified, review.IsVerified));
                    updates.Add(updateBuilder.Set(r => r.IsFeatured, review.IsFeatured));
                }

                var combinedUpdate = updateBuilder.Combine(updates);

                var result = await _reviewsCollection.UpdateOneAsync(existingReviewFilter, combinedUpdate);

                 // Check result.ModifiedCount if needed, handle concurrency etc.
                 if (!result.IsAcknowledged)
                 {
                     ModelState.AddModelError("", "Unable to save changes.");
                     return View(review); // Or appropriate error view
                 }
                 if (result.MatchedCount == 0)
                 {
                     return NotFound(); // Review disappeared between check and update
                 }

                // Redirect back to Project Details or Admin view depending on context
                if (isAdmin && Request.Headers["Referer"].ToString().Contains("/Reviews/Admin"))
                {
                     return RedirectToAction(nameof(Admin)); // Or redirect with original query params
                }
                return RedirectToAction("Details", "Projects", new { id = existingReview.ProjectId });
            }
            // Return view with model to display validation errors
            return View(review);
        }

        // POST: Reviews/Hide/5 (Now handled by Edit for Admins)
        // POST: Reviews/Unhide/5 (Example for Admin)
        [HttpPost]
        [ValidateAntiForgeryToken]
        [Authorize(Roles = "Admin")]
        public async Task<IActionResult> ToggleHide(Guid id, string? returnUrl = null) // Change id to Guid
        {
             var reviewFilter = Builders<Review>.Filter.Eq(r => r.Id, id);
             var review = await _reviewsCollection.Find(reviewFilter).FirstOrDefaultAsync();
             if (review == null)
             {
                 return NotFound();
             }

             var update = Builders<Review>.Update.Set(r => r.IsHidden, !review.IsHidden);
             await _reviewsCollection.UpdateOneAsync(reviewFilter, update);

             if (Url.IsLocalUrl(returnUrl))
             {
                return Redirect(returnUrl);
             }
             return RedirectToAction(nameof(Admin)); // Default redirect
        }

        // POST: Reviews/Delete/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        [Authorize(Roles = "Admin")] // Or Authorize based on ownership
        public async Task<IActionResult> Delete(Guid id, string? returnUrl = null) // Change id to Guid
        {
            var reviewFilter = Builders<Review>.Filter.Eq(r => r.Id, id);
            // Optional: Check ownership before deleting if non-Admins can delete
            // var review = await _reviewsCollection.Find(reviewFilter).FirstOrDefaultAsync();
            // var user = await _userManager.GetUserAsync(User);
            // if (review == null) return NotFound();
            // if (review.UserId != user.Id && !User.IsInRole("Admin")) return Forbid();

            var result = await _reviewsCollection.DeleteOneAsync(reviewFilter);

            // TODO: Also delete associated ReviewVotes
            await _reviewVotesCollection.DeleteManyAsync(v => v.ReviewId == id);

            if (Url.IsLocalUrl(returnUrl))
            {
                 return Redirect(returnUrl);
            }
            // Determine default redirect (e.g., back to project details or admin list)
            // var projectId = review?.ProjectId; // Need review object if redirecting to project
            return RedirectToAction(nameof(Admin)); // Default redirect
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Vote(Guid reviewId, bool isHelpful) // Change reviewId to Guid
        {
            var user = await _userManager.GetUserAsync(User);
            if (user == null)
            {
                return Unauthorized(); // Or Json response with error
            }
            var userId = user.Id;

            var reviewFilter = Builders<Review>.Filter.Eq(r => r.Id, reviewId);
            var review = await _reviewsCollection.Find(reviewFilter).FirstOrDefaultAsync();
            if (review == null)
            {
                return NotFound(); // Or Json response with error
            }

            var voteFilter = Builders<ReviewVote>.Filter.Eq(v => v.ReviewId, reviewId) &
                             Builders<ReviewVote>.Filter.Eq(v => v.UserId, userId);
            var existingVote = await _reviewVotesCollection.Find(voteFilter).FirstOrDefaultAsync();

            int helpfulChange = 0;
            int notHelpfulChange = 0;

            if (existingVote != null)
            {
                // Vote exists, either remove or toggle
                if (existingVote.IsHelpful == isHelpful)
                {
                    // Removing the vote
                    await _reviewVotesCollection.DeleteOneAsync(voteFilter);
                    if (isHelpful) helpfulChange = -1;
                    else notHelpfulChange = -1;
                }
                else
                {
                    // Toggling the vote
                    var voteUpdate = Builders<ReviewVote>.Update.Set(v => v.IsHelpful, isHelpful);
                    await _reviewVotesCollection.UpdateOneAsync(voteFilter, voteUpdate);
                    if (isHelpful)
                    {
                        helpfulChange = 1;
                        notHelpfulChange = -1;
                    }
                    else
                    {
                        helpfulChange = -1;
                        notHelpfulChange = 1;
                    }
                }
            }
            else
            {
                // Adding a new vote
                var newVote = new ReviewVote
                {
                    Id = Guid.NewGuid(),
                    ReviewId = reviewId,
                    UserId = userId,
                    IsHelpful = isHelpful,
                    CreatedAt = DateTime.UtcNow
                };
                await _reviewVotesCollection.InsertOneAsync(newVote);
                if (isHelpful) helpfulChange = 1;
                else notHelpfulChange = 1;
            }

            // Update counts on the Review document
            if (helpfulChange != 0 || notHelpfulChange != 0)
            {
                var reviewUpdate = Builders<Review>.Update
                    .Inc(r => r.HelpfulCount, helpfulChange)
                    .Inc(r => r.NotHelpfulCount, notHelpfulChange);
                await _reviewsCollection.UpdateOneAsync(reviewFilter, reviewUpdate);
            }

            // Return updated counts
            var updatedReview = await _reviewsCollection.Find(reviewFilter).FirstOrDefaultAsync(); // Re-fetch for updated counts
            return Json(new
            {
                helpfulCount = updatedReview?.HelpfulCount ?? review.HelpfulCount + helpfulChange,
                notHelpfulCount = updatedReview?.NotHelpfulCount ?? review.NotHelpfulCount + notHelpfulChange
            });
        }

        private async Task<bool> ReviewExists(Guid id) // Change id to Guid
        {
            return await _reviewsCollection.CountDocumentsAsync(r => r.Id == id) > 0;
        }
    }
} 